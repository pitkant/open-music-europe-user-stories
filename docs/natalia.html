<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Natalia: IT specialist orking in a collective rights management</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="natalia_files/libs/clipboard/clipboard.min.js"></script>
<script src="natalia_files/libs/quarto-html/quarto.js"></script>
<script src="natalia_files/libs/quarto-html/popper.min.js"></script>
<script src="natalia_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="natalia_files/libs/quarto-html/anchor.min.js"></script>
<link href="natalia_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="natalia_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="natalia_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="natalia_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="natalia_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Natalia: IT specialist orking in a collective rights management</h1>
<p class="subtitle lead">Entity matching</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>Persona: Natalia, 45-years-old engineer working in a collective rights management organisation. She has extensive experience working with relational database management systems, but only vague familiarity with knowledge graphs.</p>
<section id="goal" class="level3">
<h3 class="anchored" data-anchor-id="goal"><strong>Goal</strong></h3>
<ul>
<li><p>Entity matching, particularly connecting recordings (identified with ISRC) to musical works (ISWC).</p></li>
<li><p>Matching the work with the author; establishing if the author needs to be paid locally by Natália's society, or the sister society abroad needs to be informed that the author of the work needs to be paid.</p></li>
<li><p>Inform users of the work if playing the work counts into their local content requirements.</p></li>
</ul>
</section>
<section id="scenario" class="level3">
<h3 class="anchored" data-anchor-id="scenario"><strong>Scenario</strong></h3>
<p>Before: Entity matching is a struggle when the user works with recordings and not with compositions (works), because Natália does not have an up-to-date dataset of works and their known recordings. If the recordings used cannot be immediately matched with works, a semi-automated process starts where title, performer, author matching hopefully connects the used recording to the work that it embeds.</p>
<p>After: Entity matching should be a largely automated process; while a matching table may not be available for all work-recording pairs, using other mandatory metadata, such as title, names should allow the procedure to work with little human oversight.</p>
</section>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data"><strong>Data</strong></h3>
<p>The context of this story is that a fictional radio station, Radio Pelikan submitted a playlist of the songs they played (used) and Natália must make sure that the composer of the songs get paid. She also needs to ensure that other recordings of the same composition are easy to recognise in her database.</p>
<p>Natália is concerned with two key rights management tasks: to match the entity submitted with a musical work; to look up the credited author(s) or rightsholders to the musical work; and to check if the credited author(s) have any connection to the society or country.</p>
<ul>
<li><p>The RP playlist contains In Hell.</p></li>
<li><p>The global ISRC identifier of In Hell is USJ5G2022508.</p></li>
<li><p>In Hell matches up with the global ISWC identifier T-933.149.532-0 [for the abstract composition]</p></li>
<li><p>ISWC T-933.149.532-0 matches up with our local (agent ID) AB012345780.</p></li>
<li><p>In Hell has a further known live recording that was commercially released.</p></li>
<li><p>In Hell has lyrics.</p></li>
</ul>
<p>Copyrights a personal rights, and a the key aim of registering a musical work is to morally and ethically attribute the work to an author, and during the copyright protection term (during the life and 70 years after the death of the author) to identify who should receive royalties after each use of the work.</p>
<p>The work register is identifying a work and connects it with the author(s). Natália has access to CIS-Net, the private global database of author's rights organisations. The CIS-Net database is synchronized with her database on a daily basis, so she finds the following data.</p>
<ul>
<li><p>ZAUNER MICHELLE CHONGMI is the author of the musical work In Hell (work).</p></li>
<li><p>ZAUNER MICHELLE CHONGMI uses the stage name Michelle Zauner. [Most of the data sources only use Michelle Zauner].</p></li>
<li><p>Michelle Zauner is the author of the lyrics of In Hell.</p></li>
<li><p>In Hell is only credited to one author.</p></li>
<li><p>Michelle Zauner does not live in our country, or Michelle Zauner lives in the United States.</p></li>
<li><p>Michelle Zauner is not a member of our society.</p></li>
</ul>
<p>Does Natália's society need to pay Michelle Zauner for the use in Radio Pelikan? And does In Hell count into the local content quota defined by local law?</p>
<ul>
<li><p>In Hell has lyrics.</p></li>
<li><p>In Hell (lyrics) is in English. [does not count into the language quota]</p></li>
<li><p>All credited author(s all) live in the United States [do not count into the residency quota]</p></li>
<li><p>No credited author of In Hell lives in our country</p></li>
<li><p>USJ5G2022508 has a country code US [does not count into the local production quota]</p></li>
</ul>
<p>Playing In Hell does not count into the local quota and Natália's organisation does not need to pay Michelle Zauner directly; however, she has to make sure that their American sister society will pay her out in the United States. The radio play also did not count towards Radio Pelikan's local content requirement.</p>
<p><em>In Slovakia, cultural observational units are identified by name and ICO number. Unfortunately, units without legal personality do not have an ICO number.</em></p>
</section>
<section id="functional-requirements" class="level2">
<h2 class="anchored" data-anchor-id="functional-requirements">Functional requirements</h2>
<ol type="1">
<li>The names of observational units from all surveys are summarised in a practical table; name variations can be separated easily and practically from spelling errors.</li>
<li>The non-trivially wrong names (institutional titles or headings) can be checked against the VIAF, ISNI, and QID authority files, which also mark valid and invalid name variations.</li>
<li>The integrated dataset uses one of the PIDs for observational unit identification.</li>
<li>A valid, temporary identifier is issued for observational units without VIAF, ISNI, QID, or ICO numbers, for example, based on a table that conforms to the CoolURIs definition in a hash HTML table form.</li>
<li>The unit of measure is added to all currency columns; currency units can be translated to EUR/NAC values. <em>The microdata files are organised by year, and the national currency unit is not stated explicitly, in the first years it is SKK then EUR.</em></li>
<li>Metadata that is not explicit in the individual microdata files, for example, time, is made explicit. <em>The microdata files are organised by year, and the year or the date of collection or the reference period is not explicitly stated within the dataset.</em></li>
<li>A script (in the Shiny app and outside) is utilising the forecast package to interpolate and extrapolate missing values, including forecasts and backcasts.</li>
<li>The Shiny App creates visualisation and table templates that are easy to copy into a Word document.</li>
</ol>
</section>
<section id="statements" class="level2">
<h2 class="anchored" data-anchor-id="statements">Statements</h2>
<ol type="1">
<li>The <em>New Kosice Orchestra</em> and the <em>New Orchestra of Kosice</em> values can be analysed as one time series.</li>
<li>The <em>New Kosice Orchestra</em> / <em>New Orchestra of Kosice</em> has a machine-actionable PID.</li>
<li>Orchestras that are present in all 15 microdata files can be easily selected and their annual growth rate can be calculated, ranked, reported with ease.</li>
<li>The <code>Celkový počet premiér v tom diel slovenských autorov</code> has an English label version <code>Total number of premieres works of Slovak authors</code> in the dataset.</li>
<li>The <code>Celkový počet premiér v tom diel slovenských autorov</code> or <code>Total number of premieres works of Slovak authors</code> can be programatically referenced as <code>total_premiere_slovak_works</code>.</li>
<li>The <code>total_premiere_slovak_works</code> variable is always a numeric variable.</li>
<li>The <code>total_premiere_slovak_works</code> has no missing values, it is interpolated, backcasted or forecasted.</li>
<li>Because there are no missing data in the <code>total_premiere_slovak_works</code> for any observational unit, each observational unit (or its grouping) can be forecasted beyond the current timeframe of the integrated data file.</li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>